var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CFTransport","category":"page"},{"location":"#CFTransport","page":"Home","title":"CFTransport","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CFTransport.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CFTransport]","category":"page"},{"location":"#CFTransport.GodunovScheme","page":"Home","title":"CFTransport.GodunovScheme","text":"godunov! = GodunovScheme(kind, dim, rank) <: OneDimFV{dim, rank, kind}\ngodunov!(backend, newtransported, transported, flux, mass)\n\nReturns the callable godunov! that applies a one-dimensional Godunov scheme to dimension dim among rank. Computations are offloaded to backend.\n\nIf kind==:density then transported is a density. If kind==:scalar then transported is a scalar whose density is mass*transported.\n\nIf newtransported is the same as transported, it is updated in-place.\n\nThe Godunov scheme has 2, possibly 3 steps : 0 - (for densities) : compute scalar from density 1 - compute fluxes (upwind/downwind) 2 - update scalar or density\n\nBoundary conditions are left to the user. If BCs must be enforced between steps 1-2 (e.g. zero boundary fluxes), the user should rather call individual steps concentrations!, fluxes! and FV_update! .\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.OneDimFV","page":"Home","title":"CFTransport.OneDimFV","text":"abstract type OneDimFV{kind,dim,rank} end\n\nOne-dimensional finite volume transport operator acting on dimension dim of arrays of rank rank. If kind==:density the operator transports a density field (e.g. in kg/m3) If kind==:scalar the operator transports a scalar field (e.g. in kg/kg)\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.OneDimOp","page":"Home","title":"CFTransport.OneDimOp","text":"abstract type OneDimOp{dim,rank} end\n\nOne-dimensional operator acting on dimension dim of arrays of rank rank.\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.Stencil","page":"Home","title":"CFTransport.Stencil","text":"abstract type Stencil <: Function end\n\nA one-dimensional stencil is a function/closure/callable of the form\n\nfunction stencil((i,j), params, arrays)\n    a, b, ... = arrays\n    a[i,j] = expression(params, b[i,j], b[i+1,j], b[i-1,j], ...)\nend\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.VanLeerScheme","page":"Home","title":"CFTransport.VanLeerScheme","text":"vanleer! = VanLeerScheme(kind, limiter, dim, rank) <: OneDimFV{dim, rank, kind}\nvanleer!(backend, newtransported, transported, flux, mass)\n\nReturns the callable vanleer that applies a one-dimensional Van Leer scheme with limiter to dimension dim among rank. Computations are offloaded to backend.\n\nIf kind==:density then transported is a density. If kind==:scalar then transported is a scalar whose density is mass*transported.\n\nIf newtransported is the same as transported, it is updated in-place.\n\nThe VanLeer scheme has 3, possibly 4 steps : 0 - (for densities) : compute scalar from density 1 - compute slopes (with slope limiter) 2 - compute fluxes (upwind/downwind) 3 - update scalar or density\n\nBoundary conditions are left to the user. If BCs must be enforced between steps 1-2 (e.g. zero boundary slopes) and 2-3 (e.g. zero boundary fluxes), the user should rather call individual steps concentrations!, slopes!, fluxes! and FV_update! .\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.expand_stencil","page":"Home","title":"CFTransport.expand_stencil","text":"stencil = expand_stencil(dim, rank, stencil1)\n\nReturn a stencil of rank rank that applies the one-dimensional stencil stencil1 to dimension dim. For example:\n\nfunction stencil((i,j), params, arrays)\n    a, b = arrays\n    a[i,j] = expression(params, b[i,j], b[i+1,j], b[i-1,j])\nend\n\nstencil2 = expand_stencil(1, 2, stencil1)\nfor i in axes(a,1), j in axes(a,2)\n    stencil2((i,j), params, (a,b))\nend\n\nis equivalent to:\n\nfor i in axes(a,1), j in axes(a,2)\n    a[i,j] = expression(params, b[i,j], b[i,j+1], b[i,j-1])\nend\n\nSee also Stencil\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.minmod-Union{Tuple{F}, Tuple{F, F}} where F","page":"Home","title":"CFTransport.minmod","text":"slope = minmod(slope1, slope2)\n\nMinmod limiter\n\n\n\n\n\n","category":"method"},{"location":"#CFTransport.minmod_simd-Union{Tuple{F}, Tuple{F, F}} where F","page":"Home","title":"CFTransport.minmod_simd","text":"slope = minmod_simd(slope1, slope2)\n\nMinmod limiter. This implementation avoids branching and may be more suitable for SIMD vectorization.\n\n\n\n\n\n","category":"method"},{"location":"#CFTransport.remap_fluxes!","page":"Home","title":"CFTransport.remap_fluxes!","text":"remap_fluxes!(flux, newmass, mass, layout, vcoord::PressureCoordinate)\n\nComputes the target (pseudo-)mass distribution newmass prescribed by pressure-based coordinate vcoord and surface pressure ps, as well as the vertical (pseudo-)mass flux flux needed to remap from current mass distribution mass to target newmass. layout specifies the data layout, see VHLayout and HVLayout.\n\n\n\n\n\n","category":"function"}]
}
