var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CFTransport","category":"page"},{"location":"#CFTransport","page":"Home","title":"CFTransport","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CFTransport.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CFTransport]","category":"page"},{"location":"#CFTransport.GodunovScheme","page":"Home","title":"CFTransport.GodunovScheme","text":"godunov! = GodunovScheme(kind, dim, rank) <: OneDimFV{dim, rank, kind}\ngodunov!(backend, newtransported, transported, flux, mass)\n\nReturns the callable godunov! that applies a one-dimensional Godunov scheme to dimension dim among rank. Computations are offloaded to backend.\n\nIf kind==:density then transported is a density. If kind==:scalar then transported is a scalar whose density is mass*transported.\n\nIf newtransported is the same as transported, it is updated in-place.\n\nThe Godunov scheme has 2, possibly 3 steps : 0 - (for densities) : compute scalar from density 1 - compute fluxes (upwind/downwind) 2 - update scalar or density\n\nBoundary conditions are left to the user. If BCs must be enforced between steps 1-2 (e.g. zero boundary fluxes), the user should rather call individual steps concentrations!, fluxes! and FV_update! .\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.OneDimFV","page":"Home","title":"CFTransport.OneDimFV","text":"abstract type OneDimFV{kind,dim,rank} end\n\nOne-dimensional finite volume transport operator acting on dimension dim of arrays of rank rank. If kind==:density the operator transports a density field (e.g. in kg/m3) If kind==:scalar the operator transports a scalar field (e.g. in kg/kg)\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.OneDimOp","page":"Home","title":"CFTransport.OneDimOp","text":"abstract type OneDimOp{dim,rank} end\n\nOne-dimensional operator acting on dimension dim of arrays of rank rank.\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.Stencil","page":"Home","title":"CFTransport.Stencil","text":"A one-dimensional stencil is a function/closure/callable of the form\n\nfunction stencil(i, params, arrays)\n    a, b, ... = arrays\n    a[i] = expression(params, b[i], b[i+1], b[i-1], ...)\nend\n\nA two-dimensional stencil is a function/closure/callable of the form\n\nfunction stencil((i,j), params, arrays)\n    a, b, ... = arrays\n    a[i,j] = expression(params, b[i,j], b[i+1,j], b[i,j+1], ...)\nend\n\nA stencil acts at a single index. For performance, stencils should be @inline and use @inbounds.\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.VanLeerScheme","page":"Home","title":"CFTransport.VanLeerScheme","text":"vanleer! = VanLeerScheme(kind, limiter, dim, rank) <: OneDimFV{dim, rank, kind}\nvanleer!(backend, newtransported, transported, flux, mass)\n\nReturns the callable vanleer that applies a one-dimensional Van Leer scheme with limiter to dimension dim among rank. Computations are offloaded to backend.\n\nIf kind==:density then transported is a density. If kind==:scalar then transported is a scalar whose density is mass*transported.\n\nIf newtransported is the same as transported, it is updated in-place.\n\nThe VanLeer scheme has 3, possibly 4 steps : 0 - (for densities) : compute scalar from density 1 - compute slopes (with slope limiter) 2 - compute fluxes (upwind/downwind) 3 - update scalar or density\n\nBoundary conditions are left to the user. If BCs must be enforced between steps 1-2 (e.g. zero boundary slopes) and 2-3 (e.g. zero boundary fluxes), the user should rather call individual steps concentrations!, slopes!, fluxes! and FV_update! .\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.expand_stencil","page":"Home","title":"CFTransport.expand_stencil","text":"stencil = expand_stencil(dim, rank, stencil1)\n\nReturns a stencil of rank rank that applies the one-dimensional stencil stencil1 to dimension dim.\n\nstencil = apply_stencil(dims, rank, stencilN)\n\nReturns a stencil of rank rank that applies the N-dimensional stencil stencilN to the N-tuple of dimensions dims.\n\nstencil can be passed to forall :\n\nforall(stencil, backend, ranges, arrays)\n\nwhere arrays is the tuple of arrays on which the stencil acts and ranges is more or less axes(a) with a one of the arrays, except that the range over the stencil index shoud be reduced according to the stencil width to avoid out-of-bounds accesses.\n\nSee also Stencil\n\n\n\n\n\n","category":"type"},{"location":"#CFTransport.apply_stencil-Union{Tuple{S}, Tuple{Any, Any, S}} where S","page":"Home","title":"CFTransport.apply_stencil","text":"kernel = apply_stencil(dim, rank, stencil)\n\nReturns a kernel that applies a one-dimensional stencil to dimension dim of input/output arrays of rank rank\n\nkernel = apply_stencil(dims, rank, stencil)\n\nReturns a kernel that applies a multi-dimensional stencil to dimensions 'dims' of input/output arrays of rank rank.\n\nkernel can be called directly or offloaded to a backend :\n\nkernel(ranges, arrays)\n(kernel=>backend)(ranges, arrays)\n\nwhere ranges is more or less axes(a) with a one of the arrays, except that the range over the stencil index shoud be reduced according to the stencil width to avoid out-of-bounds accesses.\n\nSee also Stencil\n\n\n\n\n\n","category":"method"},{"location":"#CFTransport.minmod-Union{Tuple{F}, Tuple{F, F}} where F","page":"Home","title":"CFTransport.minmod","text":"slope = minmod(slope1, slope2)\n\nMinmod limiter\n\n\n\n\n\n","category":"method"},{"location":"#CFTransport.minmod_simd-Union{Tuple{F}, Tuple{F, F}} where F","page":"Home","title":"CFTransport.minmod_simd","text":"slope = minmod_simd(slope1, slope2)\n\nMinmod limiter. This implementation avoids branching and may be more suitable for SIMD vectorization.\n\n\n\n\n\n","category":"method"},{"location":"#CFTransport.remap_fluxes!","page":"Home","title":"CFTransport.remap_fluxes!","text":"remap_fluxes!(flux, newmass, mass, layout, vcoord::PressureCoordinate)\n\nComputes the target (pseudo-)mass distribution newmass prescribed by pressure-based coordinate vcoord and surface pressure ps, as well as the vertical (pseudo-)mass flux flux needed to remap from current mass distribution mass to target newmass. layout specifies the data layout, see VHLayout and HVLayout.\n\n\n\n\n\n","category":"function"}]
}
